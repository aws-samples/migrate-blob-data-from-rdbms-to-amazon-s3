import { Duration, Stack, StackProps, RemovalPolicy } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import cdk = require('aws-cdk-lib');
import customResources = require('aws-cdk-lib/custom-resources');
import ec2 = require('aws-cdk-lib/aws-ec2');
import iam = require("aws-cdk-lib/aws-iam");
import s3 = require('aws-cdk-lib/aws-s3');
import rds = require('aws-cdk-lib/aws-rds');
import cloudfront = require('aws-cdk-lib/aws-cloudfront');
import cloudfrontOrigin = require('aws-cdk-lib/aws-cloudfront-origins');
import lambda = require('aws-cdk-lib/aws-lambda');
import apigateway = require("aws-cdk-lib/aws-apigateway");
import logs = require("aws-cdk-lib/aws-logs");
import kms = require('aws-cdk-lib/aws-kms');
import cognito = require('aws-cdk-lib/aws-cognito');
import secretsmanager = require('aws-cdk-lib/aws-secretsmanager');
import { NagSuppressions } from 'cdk-nag';

export class WebUiS3BlobStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // Create VPC for the setup
    const serviceVPC = new ec2.Vpc(this, "ServiceVPC", {
      cidr: "10.0.0.0/16",
      maxAzs: 2,
      natGateways: 0,
      enableDnsHostnames: true,
      enableDnsSupport: true,
      gatewayEndpoints: {
        // Endpoint for necessary service as LAMBDA is in PRIVATE_ISOLATED with no network access
        S3: {
          service: ec2.GatewayVpcEndpointAwsService.S3,
        }
      },
      /**
       * Each entry in this list configures a Subnet Group
       *
       * PRIVATE_ISOLATED: Isolated Subnets do not route traffic to the Internet (in this VPC).
       * PRIVATE_NAT.: Subnet that routes to the internet, but not vice versa.
       * PUBLIC..: Subnet connected to the Internet.
       */
      subnetConfiguration: [{
        cidrMask: 24,
        name: 'private-subnet-1',
        subnetType: ec2.SubnetType.PRIVATE_ISOLATED,
      }]
    });

    // Enable flow log as part of best practice
    const flowLog = new ec2.FlowLog(this, 'VpcFlowLog', {
      resourceType: ec2.FlowLogResourceType.fromVpc(serviceVPC)
    })

    // One security group for lambda
    // This SG will be allowed to access VPC endpoint
    const lambdaSG = new ec2.SecurityGroup(this, 'lambdaSG',
      {
        vpc: serviceVPC,
        description: "Lambda Security Group",
        allowAllOutbound: false,
      });

    // There is currently no direct way to retrieve VPC Gateway PrefixList Ids for outbound security group connection
    // This is for required for lambda SG to communicate to VPC Gateway Endpoint for S3 without opening SG to all outbounds
    // For more info, please see https://docs.aws.amazon.com/vpc/latest/privatelink/vpce-gateway.html#vpc-endpoints-security
    // The current suggestion is to use a custom resource to workaround it
    // https://github.com/aws/aws-cdk/issues/15115
    // https://github.com/aws/aws-cdk/issues/13668
    const prefixLists = new customResources.AwsCustomResource(this, 'PrefixLists', {
      onUpdate: {
        service: 'EC2',
        action: 'describePrefixLists',
        parameters: {
          Filters: [
            {
              Name: 'prefix-list-name',
              Values: [`com.amazonaws.${this.region}.s3`]
            }
          ]
        },
        physicalResourceId: {}
      },
      policy: customResources.AwsCustomResourcePolicy.fromSdkCalls({
        resources: customResources.AwsCustomResourcePolicy.ANY_RESOURCE
      }),
      logRetention: 1
    });

    // Lambda SG will need to wait for prefixLists to be created before setup this below portion
    lambdaSG.node.addDependency(prefixLists);

    lambdaSG.addEgressRule(ec2.Peer.prefixList(prefixLists.getResponseField('PrefixLists.0.PrefixListId')), ec2.Port.tcp(443), 'Allow Gateway Endpoint Access');

    // Add supression to custom CFN Prefix List that scan the deployed gateway prefix to be added to the SG. It need to be wildcard as not sure what the available prefix looks like generated by VPC Gateway for S3
    // This also need wildcard access to CloudWatch Log group as cloudformation/stack will generated this group with random generated string
    NagSuppressions.addResourceSuppressions(
      prefixLists,
      [
        { id: 'AwsSolutions-IAM5', reason: 'This role require * prefix on EC2 reource to scan the generated gateway prefixList for the SG Egress to work. This also need wildcard access to CloudWatch Log group as cloudformation/stack will generated this group with random generated string' }
      ],
      true
    );

    // Enable supression at stack level as following IAM roles are generated by CDK/CDK constructor, so has random id instead of static name.
    // The random generated name cause the supression to be difficult base on different stack (as the name will keep changing), so did below as a workaround
    NagSuppressions.addResourceSuppressions(
      this,
      [
        //  /WebUiS3BlobStack/AWS679f53fac002430cb0da5b7982bd2287/ServiceRole/Resource
        // /WebUiS3BlobStack/LogRetentionaae0aa3c5b4d4f87b02d85b201efdd8a/ServiceRole/Resource
        { id: 'AwsSolutions-IAM4', reason: 'This is CDK/CDK Constructor generated AWS IAM role for managing log clean up through Lambda. The managed policy in question is AWSLambdaBasicExecutionRole, which according to AWS doc is the preferred method for managing the policy: https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html' },
        // /WebUiS3BlobStack/LogRetentionaae0aa3c5b4d4f87b02d85b201efdd8a/ServiceRole/DefaultPolicy/Resource
        { id: 'AwsSolutions-IAM5', reason: 'The wildcard policy is due to the AWSLambdaBasicExecutionRole need wildcard access to CloudWatch Log group. The log group creation is dynamic by Lambda, so this previliege is required for Lambda logging to work correctly.' },
      ],
      true
    );

    // Add required endpoints and endpoints' SG
    const cloudwatchlogVPCEndpointSG = new ec2.SecurityGroup(this, 'cloudwatchlogVPCESG',
      {
        vpc: serviceVPC,
        description: "Cloudwatch Log VPC Endpoint Security Group",
        allowAllOutbound: false,
      });
    cloudwatchlogVPCEndpointSG.connections.allowFrom(lambdaSG, ec2.Port.tcp(443));

    serviceVPC.addInterfaceEndpoint('CLOUDWATCH_LOGS', {
      service: ec2.InterfaceVpcEndpointAwsService.CLOUDWATCH_LOGS,
      securityGroups: [cloudwatchlogVPCEndpointSG],
      open: false,
      subnets: {
        subnetType: ec2.SubnetType.PRIVATE_ISOLATED
      },
    });

    const cloudwatcheventsVPCEndpointSG = new ec2.SecurityGroup(this, 'cloudwatcheventsVPCESG',
      {
        vpc: serviceVPC,
        description: "Cloudwatch Events VPC Endpoint Security Group",
        allowAllOutbound: false
      });
    cloudwatcheventsVPCEndpointSG.connections.allowFrom(lambdaSG, ec2.Port.tcp(443));

    serviceVPC.addInterfaceEndpoint('CLOUDWATCH_EVENTS', {
      service: ec2.InterfaceVpcEndpointAwsService.CLOUDWATCH_EVENTS,
      securityGroups: [cloudwatcheventsVPCEndpointSG],
      open: false,
      subnets: {
        subnetType: ec2.SubnetType.PRIVATE_ISOLATED
      },
    });

    const cloudwatchVPCEndpointSG = new ec2.SecurityGroup(this, 'cloudwatchVPCEndpointSG',
      {
        vpc: serviceVPC,
        description: "Cloudwatch VPC Endpoint Security Group",
        allowAllOutbound: false
      });
    cloudwatchVPCEndpointSG.connections.allowFrom(lambdaSG, ec2.Port.tcp(443));

    serviceVPC.addInterfaceEndpoint('CLOUDWATCH', {
      service: ec2.InterfaceVpcEndpointAwsService.CLOUDWATCH,
      securityGroups: [cloudwatchVPCEndpointSG],
      open: false,
      subnets: {
        subnetType: ec2.SubnetType.PRIVATE_ISOLATED
      },
    });
    const secretmanagerVPCEndpointSG = new ec2.SecurityGroup(this, 'secretmanagerVPCEndpointSG',
      {
        vpc: serviceVPC,
        description: "Secret Manager VPC Endpoint Security Group",
        allowAllOutbound: false
      });
    secretmanagerVPCEndpointSG.connections.allowFrom(lambdaSG, ec2.Port.tcp(443));

    serviceVPC.addInterfaceEndpoint('SECRET_MANAGER', {
      service: ec2.InterfaceVpcEndpointAwsService.SECRETS_MANAGER,
      securityGroups: [secretmanagerVPCEndpointSG],
      open: false,
      subnets: {
        subnetType: ec2.SubnetType.PRIVATE_ISOLATED
      },
    });

    const kmsVPCEndpointSG = new ec2.SecurityGroup(this, 'kmsVPCEndpointSG',
      {
        vpc: serviceVPC,
        description: "KMS VPC Endpoint Security Group",
        allowAllOutbound: false
      });
    kmsVPCEndpointSG.connections.allowFrom(lambdaSG, ec2.Port.tcp(443));

    serviceVPC.addInterfaceEndpoint('KMS', {
      service: ec2.InterfaceVpcEndpointAwsService.KMS,
      securityGroups: [kmsVPCEndpointSG],
      open: false,
      subnets: {
        subnetType: ec2.SubnetType.PRIVATE_ISOLATED
      },
    });

    const stsVPCEndpointSG = new ec2.SecurityGroup(this, 'stsVPCEndpointSG',
      {
        vpc: serviceVPC,
        description: "STS VPC Endpoint Security Group",
        allowAllOutbound: false
      });
    stsVPCEndpointSG.connections.allowFrom(lambdaSG, ec2.Port.tcp(443));

    serviceVPC.addInterfaceEndpoint('STS', {
      service: ec2.InterfaceVpcEndpointAwsService.STS,
      securityGroups: [stsVPCEndpointSG],
      open: false,
      subnets: {
        subnetType: ec2.SubnetType.PRIVATE_ISOLATED
      },
    });

    // KMS Key for website encryption includes but not limited to bucket, databases
    const kmsKey = new kms.Key(this, 'website-backend-key', {
      enableKeyRotation: true,
      removalPolicy: cdk.RemovalPolicy.DESTROY,       // Auto destroy if removed from stack
      pendingWindow: Duration.days(7)                 // Delete after 7 day once delete is triggered
    });

    // Bucket for access logs
    const accessLogsBucket = new s3.Bucket(this, 'AccessLogsBucket', {
      bucketName: 'website-internal-access-log-bucket',
      enforceSSL: true,
      publicReadAccess: false,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,             // Block all public access by default (only ACL or IAM)
      objectOwnership: s3.ObjectOwnership.BUCKET_OWNER_PREFERRED,    // Enforced is recommended, but somehow not available in CDK yet
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      encryption: s3.BucketEncryption.S3_MANAGED,
      autoDeleteObjects: true,                                       // NOT recommended for production code, this is just for easier clean up
    });

    // Enable adding suppressions to AwsSolutions-S1 to notify CDK-NAG that accessLogsBucket is a bucket for access log
    NagSuppressions.addResourceSuppressions(
      accessLogsBucket,
      [
        { id: 'AwsSolutions-S1', reason: 'This bucket itself is for server access log from other buckets, so does not have server access log enabled' },
      ],
      true
    );

    // Bucket Site Bucket
    // https://aws-cdk.com/deploying-a-static-website-using-s3-and-cloudfront/
    // Bucket to host static website content for the sample web app
    // This is a sample setup, in real world case, the set up may have existing website, then can integrate with existing one instead of using this
    // The bucket is private by default, as the serving up will be done by cloudfront

    // Note this bucket must be either using S3 Managed key or no encrpytion, as current CloudFront Origin Access Identity cannot decrypt customer managed KMS key
    // If using customer managed key, will cause an error serving with key error
    // https://aws.amazon.com/premiumsupport/knowledge-center/s3-website-cloudfront-error-403/ -> Objects in the bucket can't be AWS KMS-encrypted
    // Note the article about bucket must be public access, it is now resolved through cloudfrontdistribution, so the bucket no longer need to be public access for the cloudfront to work
    const websiteBucket = new s3.Bucket(this, 'WebsiteBucket', {
      bucketName: 'website-s3-static-site',
      enforceSSL: true,
      publicReadAccess: false,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,             // Block all public access by default (only ACL or IAM)
      objectOwnership: s3.ObjectOwnership.BUCKET_OWNER_PREFERRED,    // Enforced is recommended, but somehow not available in CDK yet
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      encryption: s3.BucketEncryption.S3_MANAGED,
      autoDeleteObjects: true,                                       // NOT recommended for production code, this is just for easier clean up
      serverAccessLogsBucket: accessLogsBucket,
      serverAccessLogsPrefix: 'WebsiteBucket',
    });

    const originAccessIdentity = new cloudfront.OriginAccessIdentity(this, 's3OriginAccessIdentity', {});
    websiteBucket.grantRead(originAccessIdentity);

  // Creating a custom response headers policy -- all parameters optional
  const cloudfrontResponseHeadersPolicy = new cloudfront.ResponseHeadersPolicy(this, 'ResponseHeadersPolicy', {
    responseHeadersPolicyName: 'CloudFrontCustomSecurityPolicy',
    comment: 'A default security policy to eliminate XSS',
    securityHeadersBehavior: {
      // Need to add blob: as it is what used by UI to compatible with RDBMS BLOB token only API (see sites/js/app_rdbms.js for detail on how that API is retriving and cache)
      contentSecurityPolicy: { contentSecurityPolicy: "object-src 'self' blob: https:; img-src 'self' blob: https:; script-src 'self' https://sdk.amazonaws.com;  default-src https:;", override: true },
      contentTypeOptions: { override: true },
      frameOptions: { frameOption: cloudfront.HeadersFrameOption.DENY, override: true },
      referrerPolicy: { referrerPolicy: cloudfront.HeadersReferrerPolicy.NO_REFERRER, override: true },
      strictTransportSecurity: { accessControlMaxAge: Duration.seconds(63072000), includeSubdomains: true, override: true },
      xssProtection: { protection: true, modeBlock: true, override: true },
    },
  });

    // Creates a distribution from an S3 bucket.
    const cloudfrontDistribution = new cloudfront.Distribution(this, 'cloudfrontDistribution', {
      defaultBehavior: {
        origin: new cloudfrontOrigin.S3Origin(websiteBucket, {
          originAccessIdentity: originAccessIdentity
        }),
        responseHeadersPolicy: cloudfrontResponseHeadersPolicy,
        viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.HTTPS_ONLY
      },
      minimumProtocolVersion: cloudfront.SecurityPolicyProtocol.TLS_V1_2_2021,
      defaultRootObject: "index.html",
      logBucket: accessLogsBucket,
      enableLogging: true
    });

    // Enable adding suppressions to not place a geo restriction, as this code sample is setup to be generic
    // Enable supression for not enabling WAFv2, as the setup will be vary base on each custom use case, so keep the setup generic for now, a note is added to notify user to review the setting and adjusted before moving to production
    // A note is placed to notify user to reconsider these settings based on the his/her security seetings.
    NagSuppressions.addResourceSuppressions(
      cloudfrontDistribution,
      [
        { id: 'AwsSolutions-CFR1', reason: 'Currently not using Geo restrictions on CloudFront as the code sample is setup to be generic. A note is placed on README to notify user to reconsider this setting based on the his/her security seetings.' },
        { id: 'AwsSolutions-CFR2', reason: 'Currently not enable WAF integration as the setup will be vary base on each custom use case, so keep the setup generic for now, a note is added to notify user to review the setting and adjusted before moving to production' },
        { id: 'AwsSolutions-CFR4', reason: 'Currently not enable keep default viewer certificate with explict minimumProtocolVersion set to restrict. This is to keep the code generic without forcing specific domain/cert despite minimumProtocolVersion is not fully working at this point. A note is added to notify user to review the setting and adjusted before moving to production' }
      ],
      true
    );

    // Retreive the static content distribution
    const siteBucketWebsiteURL = 'https://' + cloudfrontDistribution.distributionDomainName;
    //const siteBucketWebsiteURL = 'http://localhost:8080';

    // Reference from https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/s3-example-photo-album.html
    // Set up so WEB UI can download BLOB from S3 content on behave of user
    const corsRule: s3.CorsRule = {
      allowedMethods: [
        s3.HttpMethods.HEAD,
        s3.HttpMethods.GET,
        s3.HttpMethods.PUT,
        s3.HttpMethods.POST,
        s3.HttpMethods.DELETE,
      ],
      allowedOrigins: [siteBucketWebsiteURL],
      allowedHeaders: ["*"], // Need to allow headers to resolve CORS issue with headerObject from web browser
      exposedHeaders: ['ETag'],
    };

    // Bucket website-blob-location
    // The S3 bucket to store the blob from the database
    const contentBucket = new s3.Bucket(this, 'website-blob-location', {
      enforceSSL: true,                                              // ForceSSL
      publicReadAccess: false,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,             // Block all public access by default (only ACL or IAM)
      //objectOwnership: s3.ObjectOwnership.BUCKET_OWNER_ENFORCED,
      objectOwnership: s3.ObjectOwnership.BUCKET_OWNER_PREFERRED,    // Enforced is recommended, but somehow not available in CDK yet
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      encryption: s3.BucketEncryption.KMS,                           // KMS Key encrpytion enabled
      encryptionKey: kmsKey,
      autoDeleteObjects: true,                                        // NOT recommended for production code, this is just for easier clean up
      cors: [corsRule],
      serverAccessLogsBucket: accessLogsBucket,
      serverAccessLogsPrefix: 'SiteBucket',
    });

    /**
     * AuroraCluster
     * PSQL Aurora Serverless database to store the order info
     */
    const auroraClusterDatabaseName = 'main';
    const auroraClusterDatabaseTableName = 'orders';
    const auroraClusterDatabaseRDBMSBlobTableName = 'orders_rdbms_blob';
    const auroraClusterDatabaseUsername = 'admin'; // default created username
    
    const rdsAuroraPort = 33306; // Assign a new obscated port for RDS cluster for AwsSolutions-RDS11

    // SG for RDS
    const rdsAuroraProxyPort = 3306; // RDS Proxy currently only support standard 3306 port https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html

    
    const rdsauroraSG = new ec2.SecurityGroup(this, 'rdsauroraSG', {
      vpc: serviceVPC,
      description: 'SecurityGroup for RDS Aurora Cluster',
      allowAllOutbound: false
    });

    // For lambda to rdsAuroraSG connection
    rdsauroraSG.connections.allowFrom(lambdaSG, ec2.Port.tcp(rdsAuroraProxyPort), 'Lambda to RDS Aurora MySQL Proxy Port ' + rdsAuroraProxyPort);

    // For RDS Proxy to RDS Aurora connection
    rdsauroraSG.connections.allowFrom(rdsauroraSG, ec2.Port.tcp(rdsAuroraPort), 'RDS Proxy to Aurora MySQL Port ' + rdsAuroraPort);

    const auroraCluster = new rds.DatabaseCluster(this, 'AuroraMySQLCluster', {
      defaultDatabaseName: auroraClusterDatabaseName,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      engine: rds.DatabaseClusterEngine.AURORA_MYSQL,
      storageEncrypted: true,
      storageEncryptionKey: kmsKey,
      port: rdsAuroraPort,
      iamAuthentication: true,
      deletionProtection: true,
      backtrackWindow: Duration.hours(24), // Backtrack for 24 hr
      instances: 2,
      backup: { retention: cdk.Duration.days(1) },
      instanceProps: {
        allowMajorVersionUpgrade: true,
        // Need medium or above to support IAM authentication https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html#UsingWithRDS.IAMDBAuth.Availability
        instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.MEDIUM),
        securityGroups: [rdsauroraSG],
        vpcSubnets: {
          subnetType: ec2.SubnetType.PRIVATE_ISOLATED,
        },
        vpc: serviceVPC,
        publiclyAccessible: false
      },
    });

    // add rotation to DB master secret
    auroraCluster.addRotationSingleUser({
      automaticallyAfter: cdk.Duration.days(30),
    });

    const auroraClusterProxy = auroraCluster.addProxy('AuroraMySQLClusterProxy', {
      secrets: [auroraCluster.secret!],
      vpc: serviceVPC,
      iamAuth: true,
      requireTLS: true,
      vpcSubnets: {
        subnetType: ec2.SubnetType.PRIVATE_ISOLATED,
      },
      securityGroups: [rdsauroraSG]
    });


    const mysqlLambdaLayer = new lambda.LayerVersion(this, 'mysqlLambdaLayer', {
      code: lambda.Code.fromAsset('lambda_fns_layer'),
      compatibleRuntimes: [lambda.Runtime.NODEJS_14_X],
      description: 'A layer that contains the mysql client module',
      license: 'MIT License'
    });

    // Role dbSetupFunctionRole
    // Role used by user dbSetup lamdba
    const dbSetupFunctionRole = new iam.Role(this, "db_setup_function_role", {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com')
    });

    // Add minimum AWS lambda roles (from cloudwatch logs etc)
    dbSetupFunctionRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'));
    dbSetupFunctionRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AWSXRayDaemonWriteAccess'));
    // Need this permission role in order for lambda to be deployed, otherwise will error out with the error
    // The provided execution role does not have permissions to call DescribeNetworkInterfaces on EC2
    // In theory, this option covers the AWS Lambda basic role (cloudwatch portion), but still added both to be more explict
    dbSetupFunctionRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaVPCAccessExecutionRole'));

    // Add permission to allow use of RDS Proxy
    auroraClusterProxy.grantConnect(dbSetupFunctionRole, auroraClusterDatabaseUsername);

    // Lambda orderTargetFunction
    // Act as the back end computing for the user endpoint
    const dbSetupFunction = new lambda.Function(this, "dbSetupFunction", {
      runtime: lambda.Runtime.NODEJS_14_X,
      memorySize: 128,
      code: lambda.Code.fromAsset("lambda_fns"),
      handler: "db_setup.main",
      architecture: lambda.Architecture.ARM_64,
      role: dbSetupFunctionRole,
      // place lambda in VPC
      vpc: serviceVPC,
      layers: [mysqlLambdaLayer],
      securityGroups: [lambdaSG],
      // place lambda in subnet
      vpcSubnets: { subnetType: ec2.SubnetType.PRIVATE_ISOLATED },
      timeout: Duration.seconds(5),
      environment: {
        AURORA_CLUSTER_PROXY_HOSTNAME: auroraClusterProxy.endpoint,
        AURORA_CLUSTER_PROXY_PORT: '' + rdsAuroraProxyPort,
        AURORA_CLUSTER_USERNAME: auroraClusterDatabaseUsername,
        AURORA_CLUSTER_DATABASE_NAME: auroraClusterDatabaseName,
        AURORA_TABLE_NAME: auroraClusterDatabaseTableName,
      }
    });

    // Enable adding suppressions to AwsSolutions-IAM4 to notify CDK-NAG that 
    // This computingLambda only used required AWS Managed Lambda policies. These polices according to documentation https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html is recommended to use over manually add policy. As Lambda will need to access random cloudwatch/XRAY endpoint base on input requirement
    // The wildcard is coming from AWS Managed Lambda policy due to how Lambda dynamically create cloudwatch/xray setup on start up
    NagSuppressions.addResourceSuppressions(
      dbSetupFunctionRole,
      [
        { id: 'AwsSolutions-IAM4', reason: 'This dbSetupFunctionRole only used required AWS Managed Lambda policies. These polices according to documentation https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html is recommended to use over manually add policy. As Lambda will need to access random cloudwatch/XRAY endpoint base on input requirement' },
        { id: 'AwsSolutions-IAM5', reason: 'This wildcard permission comes from AWS Managed Lambda policies for cloudwatch/xray, which is required as lambda cannot control cloudwatch log group name in advance and require wildcard permission to create on fly so cannot be replaced' }
      ],
      true
    );

    // Role orderFunctionRole
    // Role used by user computing lamdba, need to explictly declare to assign the policy to allow the Lambda to call AWS STS service to retrieve temporary token
    const orderFunctionRole = new iam.Role(this, "order_function_role", {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com')
    });

    // Role templateS3IAMRole
    // Creates a limited S3 role to access bucke
    // This limited role will need full access over the bucket that contains all actions assume role will need to take
    // , as the assume role logic can only restrict but not add additional previliges behind the base role's plicy
    // For example, the assume role's inline policy cannot expand to other prefix if the base role is limited only to certain prefix
    const templateS3Role = new iam.Role(this, "template_s3_role", {
      assumedBy: new iam.ArnPrincipal(orderFunctionRole.roleArn) // This role can only be assumed by the user role Lamdba so lock to the ARN
    });

    // In this example, all assume role access will be READ/WRITE only, so only granted respect settings
    contentBucket.grantReadWrite(templateS3Role);

    // Enable adding suppressions to AwsSolutions-IAM5 to notify CDK-NAG that 
    // This templateS3Role need wildcard permission on the S3 bucket as it will have full read/write access
    NagSuppressions.addResourceSuppressions(
      templateS3Role,
      [
        { id: 'AwsSolutions-IAM5', reason: 'This wildcard permission comes from wildcard access to fully control read/write on the target S3 bucket' }
      ],
      true
    );

    // Add the policy to allow the lamba user function role to call STS to assume the template role
    // Important: 
    // The requester role (user lamda role) must have STS to assume role on target (template role)
    // AND
    // The target role (template role) must trust the requester (either through explict or through more broad access like anyprincipal, broad access is not recommend due to least previlige)
    // For this to work, miss one part will result denied of access

    // If need session tag
    // https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_permissions-required
    orderFunctionRole.addToPolicy(new iam.PolicyStatement({
      resources: [templateS3Role.roleArn],
      actions: ['sts:AssumeRole']
    }));

    // Add minimum AWS lambda roles (from cloudwatch logs etc)
    orderFunctionRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'));
    orderFunctionRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AWSXRayDaemonWriteAccess'));
    // Need this permission role in order for lambda to be deployed, otherwise will error out with the error
    // The provided execution role does not have permissions to call DescribeNetworkInterfaces on EC2
    // In theory, this option covers the AWS Lambda basic role (cloudwatch portion), but still added both to be more explict
    orderFunctionRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaVPCAccessExecutionRole'));

    // Add permission to allow use of RDS Proxy
    auroraClusterProxy.grantConnect(orderFunctionRole, auroraClusterDatabaseUsername);
    // Function will use read/write to delete assoicated s3 asset after the DB record is removed
    contentBucket.grantReadWrite(orderFunctionRole);

    // Lambda orderTargetFunction
    // Act as the back end computing for the user endpoint
    const orderFunction = new lambda.Function(this, "orderFunction", {
      runtime: lambda.Runtime.NODEJS_14_X,
      memorySize: 128,
      code: lambda.Code.fromAsset("lambda_fns"),
      handler: "order.main",
      architecture: lambda.Architecture.ARM_64,
      role: orderFunctionRole,
      // place lambda in VPC
      vpc: serviceVPC,
      layers: [mysqlLambdaLayer],
      securityGroups: [lambdaSG],
      // place lambda in subnet
      vpcSubnets: { subnetType: ec2.SubnetType.PRIVATE_ISOLATED },
      timeout: Duration.seconds(5),
      environment: {
        BUCKET: contentBucket.bucketArn,                      // Assign the bucket ARN to the lamda function environment variable to be used in code
        BUCKET_ENCRYPTION: kmsKey.keyArn,              // Assign the encrpytion key to the lambda function envrionment variable to be used in the code (as assume role need to explictly call out it)
        TEMPLATE_IAM_ROLE: templateS3Role.roleArn,     // Assign the role ARN to the lamda function environment variable to be used in code
        AURORA_CLUSTER_PROXY_HOSTNAME: auroraClusterProxy.endpoint,
        AURORA_CLUSTER_PROXY_PORT: '' + rdsAuroraProxyPort,
        AURORA_CLUSTER_USERNAME: auroraClusterDatabaseUsername,
        AURORA_CLUSTER_DATABASE_NAME: auroraClusterDatabaseName,
        AURORA_TABLE_NAME: auroraClusterDatabaseTableName,
        STS_TOKEN_DURATION_SECONDS: "900",                 // Assign a low duration (900 is minimum for STS currently as of this written otherwise API will error out) seconds to increase security to force need to frequently use valid login to exchange for valid token
        ACCESS_CONTROL_ALLOW_ORIGIN: siteBucketWebsiteURL // Assign url to be used in origin response header
      }
    });

    // Enable adding suppressions to AwsSolutions-IAM4 to notify CDK-NAG that 
    // This computingLambda only used required AWS Managed Lambda policies. These polices according to documentation https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html is recommended to use over manually add policy. As Lambda will need to access random cloudwatch/XRAY endpoint base on input requirement
    // The wildcard is coming from AWS Managed Lambda policy due to how Lambda dynamically create cloudwatch/xray setup on start up
    NagSuppressions.addResourceSuppressions(
      orderFunctionRole,
      [
        { id: 'AwsSolutions-IAM4', reason: 'This computingLambdaRole only used required AWS Managed Lambda policies. These polices according to documentation https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html is recommended to use over manually add policy. As Lambda will need to access random cloudwatch/XRAY endpoint base on input requirement' },
        { id: 'AwsSolutions-IAM5', reason: 'This wildcard permission comes from AWS Managed Lambda policies for cloudwatch/xray, which is required as lambda cannot control cloudwatch log group name in advance and require wildcard permission to create on fly so cannot be replaced' }
      ],
      true
    );

    // Link the APIGateway for Users with Lamda Users Handler
    const orderAPIIntegration = new apigateway.LambdaIntegration(orderFunction, {
      requestTemplates: { "application/json": '{ "statusCode": "200" }' }
    });

    const orderAPICORSMockIntegration = new apigateway.MockIntegration();

    // Use the cognito authorizer
    var cognitoUserPool = this.createCognitoUserPool(siteBucketWebsiteURL);

    // API Gateway cognito pool authorizer
    const authorizer = new apigateway.CognitoUserPoolsAuthorizer(this, 'apiCognitoPoolAuthorizer', {
      cognitoUserPools: [cognitoUserPool]
    });

    const orderAPILogs = new logs.LogGroup(this, "order-api-logs");

    // APIGateWay for Order
    // Act as the API in front of Lamda UsersHandler
    const orderAPI = new apigateway.RestApi(this, "order-api", {
      restApiName: "Order Service",
      description: "This service serves order related info.",
      defaultCorsPreflightOptions: {                 // CROS is necessary in this sample as the API Gateway (API) and Cloudfront (Static site) are two different origin
        allowOrigins: [siteBucketWebsiteURL],
        allowHeaders: ['Content-Type', 'X-Amz-Date', 'Authorization', 'X-Api-Key', 'X-Amz-Security-Token'],
        allowCredentials: true,
        allowMethods: ['GET', 'OPTIONS', 'PUT', 'POST', 'DELETE']
      },
      deployOptions: {            // Default logging for all API endpoint dervied from this REST API
        loggingLevel: apigateway.MethodLoggingLevel.ERROR,
        accessLogDestination: new apigateway.LogGroupLogDestination(orderAPILogs), // Enable Access Logging per AwsSolutions-APIG1
        accessLogFormat: apigateway.AccessLogFormat.jsonWithStandardFields({
          caller: false,
          httpMethod: true,
          ip: true,
          protocol: true,
          requestTime: true,
          resourcePath: true,
          responseLength: true,
          status: true,
          user: true
        })
      }
    });

    // Enable supression for input validation as it will be performed by backend logic (as certain field is optional and in certain format)
    // Enable supression for using managing log group, as the managed policy in this case is need for AWS API Gateway to create/log logs into Cloudwatch Logs and is preffered method according to AWS Doc
    // Enable supression for not enabling WAFv2, as the setup will be vary base on each custom use case, so keep the setup generic for now, a note is added to notify user to review the setting and adjusted before moving to production
    NagSuppressions.addResourceSuppressions(
      orderAPI,
      [
        { id: 'AwsSolutions-APIG2', reason: 'Backend integration Lambda will perform necessary validation on input parameters according to business logic.' },
        { id: 'AwsSolutions-APIG3', reason: 'The setup will be vary base on each custom use case, so keep the setup generic for now, a note is added to notify user to review the setting and adjusted before moving to production' },
        { id: 'AwsSolutions-IAM4', reason: 'This is generated AWS IAM role for managing log from CDK/API Gateway constructor. The managed policy in question is AmazonAPIGatewayPushToCloudWatchLogs and is the preffered way to setup according to AWS doc https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html' },
      ],
      true
    );

    // Set the GET HTTP method to allow to pass through this new API
    // Integrate the API token authorizer, as need both /orders and /order/{orderId}, so add lambda integration to both

    // For query all items
    const ordersResource = orderAPI.root.addResource("orders");
    ordersResource.addMethod("GET", orderAPIIntegration, {
      authorizer: authorizer    // Default authorizer for all API derived from this REST API
    });

    const orderResource = orderAPI.root.addResource("order");
    // For order item creation
    orderResource.addMethod("POST", orderAPIIntegration, {
      authorizer: authorizer
    });

    const orderIDResource = orderResource.addResource("{orderId}");

    // Get exact order item record base on ID
    orderIDResource.addMethod("GET", orderAPIIntegration, {
      authorizer: authorizer
    });
    // Update order item record base on ID
    orderIDResource.addMethod("PUT", orderAPIIntegration, {
      authorizer: authorizer
    });
    // Delete order item record base on ID
    orderIDResource.addMethod("DELETE", orderAPIIntegration, {
      authorizer: authorizer
    });

    // Create an presignedPost for file upload
    const orderIDPutSignedURLResource = orderIDResource.addResource("presignedPost");
    orderIDPutSignedURLResource.addMethod("POST", orderAPIIntegration, {
      authorizer: authorizer
    });

    // Enable adding suppressions to on OPTIONS endpoint for Options under the given resource as this endpoint is intend to not have authorization to serve CORS correctly
    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-api/Default/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );
    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-api/Default/orders/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );
    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-api/Default/order/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );

    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-api/Default/order/{orderId}/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );

    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-api/Default/order/{orderId}/presignedPost/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );

    this.createRDBMSBlobAPI(
      serviceVPC,
      auroraClusterProxy,
      rdsAuroraProxyPort,
      auroraClusterDatabaseUsername,
      auroraClusterDatabaseName,
      auroraClusterDatabaseRDBMSBlobTableName,
      lambdaSG,
      mysqlLambdaLayer,
      cognitoUserPool,
      siteBucketWebsiteURL);


    // Output for easier identification
    new cdk.CfnOutput(this, 'WebsiteURL', { value: siteBucketWebsiteURL });
    new cdk.CfnOutput(this, 'S3BLOBBucketName', { value: contentBucket.bucketName });
    new cdk.CfnOutput(this, 'S3WebsiteBucketName', { value: websiteBucket.bucketName });
    new cdk.CfnOutput(this, 'DBSetupLambdaFunctionName', { value: dbSetupFunction.functionName });
  }

  createRDBMSBlobAPI(
    serviceVPC: cdk.aws_ec2.IVpc,
    auroraClusterProxy: cdk.aws_rds.DatabaseProxy,
    rdsAuroraProxyPort: number,
    auroraClusterDatabaseUsername: string,
    auroraClusterDatabaseName: string,
    auroraClusterDatabaseTableName: string,
    lambdaSG: cdk.aws_ec2.ISecurityGroup,
    mysqlLambdaLayer: cdk.aws_lambda.LayerVersion,
    cognitoUserPool: cdk.aws_cognito.IUserPool,
    siteBucketWebsiteURL: string) {


    // Role orderRDBMSBlobFunctionRole
    // Role used by user computing lamdba, need to explictly declare to assign the policy to allow the Lambda to call AWS STS service to retrieve temporary token
    const orderRDBMSBlobFunctionRole = new iam.Role(this, "order_rdbms_blob_function_role", {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com')
    });

    // Add minimum AWS lambda roles (from cloudwatch logs etc)
    orderRDBMSBlobFunctionRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'));
    orderRDBMSBlobFunctionRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AWSXRayDaemonWriteAccess'));
    // Need this permission role in order for lambda to be deployed, otherwise will error out with the error
    // The provided execution role does not have permissions to call DescribeNetworkInterfaces on EC2
    // In theory, this option covers the AWS Lambda basic role (cloudwatch portion), but still added both to be more explict
    orderRDBMSBlobFunctionRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaVPCAccessExecutionRole'));

    // Add permission to allow use of RDS Proxy
    auroraClusterProxy.grantConnect(orderRDBMSBlobFunctionRole, auroraClusterDatabaseUsername);

    // Lambda orderTargetFunction
    // Act as the back end computing for the user endpoint
    const orderRDBMSBlobFunction = new lambda.Function(this, "orderRDBMSBlobFunction", {
      runtime: lambda.Runtime.NODEJS_14_X,
      memorySize: 128,
      code: lambda.Code.fromAsset("lambda_fns"),
      handler: "order_rdbms_blob.main",
      architecture: lambda.Architecture.ARM_64,
      role: orderRDBMSBlobFunctionRole,
      // place lambda in VPC
      vpc: serviceVPC,
      layers: [mysqlLambdaLayer],
      securityGroups: [lambdaSG],
      // place lambda in subnet
      vpcSubnets: { subnetType: ec2.SubnetType.PRIVATE_ISOLATED },
      timeout: Duration.seconds(10),
      environment: {
        AURORA_CLUSTER_PROXY_HOSTNAME: auroraClusterProxy.endpoint,
        AURORA_CLUSTER_PROXY_PORT: '' + rdsAuroraProxyPort,
        AURORA_CLUSTER_USERNAME: auroraClusterDatabaseUsername,
        AURORA_CLUSTER_DATABASE_NAME: auroraClusterDatabaseName,
        AURORA_TABLE_NAME: auroraClusterDatabaseTableName,
        ACCESS_CONTROL_ALLOW_ORIGIN: siteBucketWebsiteURL // Assign url to be used in origin response header
      }
    });

    // Enable adding suppressions to AwsSolutions-IAM4 to notify CDK-NAG that 
    // This computingLambda only used required AWS Managed Lambda policies. These polices according to documentation https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html is recommended to use over manually add policy. As Lambda will need to access random cloudwatch/XRAY endpoint base on input requirement
    // The wildcard is coming from AWS Managed Lambda policy due to how Lambda dynamically create cloudwatch/xray setup on start up
    NagSuppressions.addResourceSuppressions(
      orderRDBMSBlobFunctionRole,
      [
        { id: 'AwsSolutions-IAM4', reason: 'This computingLambdaRole only used required AWS Managed Lambda policies. These polices according to documentation https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html is recommended to use over manually add policy. As Lambda will need to access random cloudwatch/XRAY endpoint base on input requirement' },
        { id: 'AwsSolutions-IAM5', reason: 'This wildcard permission comes from AWS Managed Lambda policies for cloudwatch/xray, which is required as lambda cannot control cloudwatch log group name in advance and require wildcard permission to create on fly so cannot be replaced' }
      ],
      true
    );


    // APIGateWay for Order with RDBMS Blob

    // In order for binary (in this case serving image/png binary) to working, following settings need to be enabled:
    // 1. In orderRDBMSBlobAPI apigateway.RestApi, binaryMediaTypes need to include 'image/png' for request/response with accept/content-type 'image/png' to be working as binary within given APIGateway object
    // 2. In orderRDBMSBlobAPIBinaryHandlingIntegration apigateway.LambdaIntegration integration, the contentHandling set to apigateway.ContentHandling.CONVERT_TO_BINARY
    // 4. Lambda will retrive and send response with appropriate header content type (image/png) + retrieve as binary and response as base64

    // API Gateway cognito pool authorizer for orderRDBMSBlobAPI (need one authorizer for each API gateway, cannot be reused)
    const authorizerRDBMSBlob = new apigateway.CognitoUserPoolsAuthorizer(this, 'apiCognitoPoolAuthorizerRDBMSBlob', {
      cognitoUserPools: [cognitoUserPool]
    });

    const orderRDBMSBlobAPILogs = new logs.LogGroup(this, "order-rdbmsblob-api-logs");

    // Act as the API in front of Lamda UsersHandler
    const orderRDBMSBlobAPI = new apigateway.RestApi(this, "order-rdbmsblob-api", {
      restApiName: "Order Service with RDBMS BLOB",
      description: "This service serves order related info with RDBMS BLOB",
      binaryMediaTypes: ['image/png'],
      minimumCompressionSize: 0,
      defaultCorsPreflightOptions: {                 // CROS is necessary in this sample as the API Gateway (API) and Cloudfront (Static site) are two different origin
        allowOrigins: [siteBucketWebsiteURL],
        allowHeaders: ['Content-Type', 'X-Amz-Date', 'Authorization', 'X-Api-Key', 'X-Amz-Security-Token'],
        allowCredentials: true,
        allowMethods: ['GET', 'OPTIONS', 'PUT', 'POST', 'DELETE']
      },
      deployOptions: {            // Default logging for all API endpoint dervied from this REST API
        loggingLevel: apigateway.MethodLoggingLevel.ERROR,
        accessLogDestination: new apigateway.LogGroupLogDestination(orderRDBMSBlobAPILogs),  // Enable Access Logging per AwsSolutions-APIG1
        accessLogFormat: apigateway.AccessLogFormat.jsonWithStandardFields({
          caller: false,
          httpMethod: true,
          ip: true,
          protocol: true,
          requestTime: true,
          resourcePath: true,
          responseLength: true,
          status: true,
          user: true
        })
      }
    });


    // Enable supression for input validation as it will be performed by backend logic (as certain field is optional and in certain format)
    // Enable supression for using managing log group, as the managed policy in this case is need for AWS API Gateway to create/log logs into Cloudwatch Logs and is preffered method according to AWS Doc
    // Enable supression for not enabling WAFv2, as the setup will be vary base on each custom use case, so keep the setup generic for now, a note is added to notify user to review the setting and adjusted before moving to production
    NagSuppressions.addResourceSuppressions(
      orderRDBMSBlobAPI,
      [
        { id: 'AwsSolutions-APIG2', reason: 'Backend integration Lambda will perform necessary validation on input parameters according to business logic.' },
        { id: 'AwsSolutions-IAM4', reason: 'This is generated AWS IAM role for managing log from CDK/API Gateway constructor. The managed policy in question is AmazonAPIGatewayPushToCloudWatchLogs and is the preffered way to setup according to AWS doc https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html' },
        { id: 'AwsSolutions-APIG3', reason: 'The setup will be vary base on each custom use case, so keep the setup generic for now, a note is added to notify user to review the setting and adjusted before moving to production' },
      ],
      true
    );

    // Link the APIGateway for Users with Lamda Users Handler
    const orderRDBMSBlobAPIIntegration = new apigateway.LambdaIntegration(orderRDBMSBlobFunction, {
      requestTemplates: { "application/json": '{ "statusCode": "200" }' }
    });

    // Link the APIGateway for Users with Lamda Users Handler
    // This integration used the binary handling mechanism from standard JSON conversation
    const orderRDBMSBlobAPIBinaryHandlingIntegration = new apigateway.LambdaIntegration(orderRDBMSBlobFunction, {
      contentHandling: apigateway.ContentHandling.CONVERT_TO_BINARY,
      requestTemplates: { "image/png": '{ "statusCode": "200" }' },
    });

    // Set the GET HTTP method to allow to pass through this new API
    // Integrate the API token authorizer, as need both /orders and /order/{orderId}, so add lambda integration to both
    // For query all items
    const ordersRDBMSBlobResource = orderRDBMSBlobAPI.root.addResource("orders");
    ordersRDBMSBlobResource.addMethod("GET", orderRDBMSBlobAPIIntegration, {
      authorizer: authorizerRDBMSBlob
    });

    const orderRDBMSBlobResource = orderRDBMSBlobAPI.root.addResource("order");
    // For order item creation
    orderRDBMSBlobResource.addMethod("POST", orderRDBMSBlobAPIIntegration, {
      authorizer: authorizerRDBMSBlob
    });

    const orderRDBMSBlobIDResource = orderRDBMSBlobResource.addResource("{orderId}");
    // Get exact order item record base on ID
    orderRDBMSBlobIDResource.addMethod("GET", orderRDBMSBlobAPIIntegration, {
      authorizer: authorizerRDBMSBlob
    });
    // Update order item record base on ID
    orderRDBMSBlobIDResource.addMethod("PUT", orderRDBMSBlobAPIIntegration, {
      authorizer: authorizerRDBMSBlob
    });
    // Delete order item record base on ID
    orderRDBMSBlobIDResource.addMethod("DELETE", orderRDBMSBlobAPIIntegration, {
      authorizer: authorizerRDBMSBlob
    });

    const orderRDBMSBlobIDBlobResource = orderRDBMSBlobIDResource.addResource("blob");
    // Get blob for exact order item record base on ID
    orderRDBMSBlobIDBlobResource.addMethod("GET", orderRDBMSBlobAPIBinaryHandlingIntegration, {
      authorizer: authorizerRDBMSBlob
    });
    orderRDBMSBlobIDBlobResource.addMethod("POST", orderRDBMSBlobAPIBinaryHandlingIntegration, {
      authorizer: authorizerRDBMSBlob
    });

    // Enable adding suppressions to on OPTIONS endpoint for Options under the given resource as this endpoint is intend to not have authorization to serve CORS correctly
    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-rdbmsblob-api/Default/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );
    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-rdbmsblob-api/Default/orders/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );
    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-rdbmsblob-api/Default/order/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );

    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-rdbmsblob-api/Default/order/{orderId}/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );

    NagSuppressions.addResourceSuppressionsByPath(
      this,
      '/WebUiS3BlobStack/order-rdbmsblob-api/Default/order/{orderId}/blob/OPTIONS/Resource',
      [
        { id: 'AwsSolutions-APIG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' },
        { id: 'AwsSolutions-COG4', reason: 'This endpoint is set to no authorizer as it is serving the necessary HEADERS for CORS correctly. It is an auto generated endpoint by API Gateway constructor with pre-flight options' }
      ],
      true
    );
  }

  createCognitoUserPool(siteBucketWebsiteURL: string): cognito.IUserPool {

    // Use cloudformation construct as high level construct does not support Advanced Security 
    // Reference https://github.com/aws/aws-cdk/issues/7405
    const cfnUserPool = new cognito.CfnUserPool(this, 'cfnUserPool', {
      accountRecoverySetting: {
        recoveryMechanisms: [{
          name: 'verified_email',
          priority: 1,
        }],
      },
      adminCreateUserConfig: {
        allowAdminCreateUserOnly: false
      },
      autoVerifiedAttributes: ["email"],
      mfaConfiguration: 'ON',
      enabledMfas: ['SOFTWARE_TOKEN_MFA'],
      policies: {
        passwordPolicy: {
          minimumLength: 12,
          requireLowercase: true,
          requireNumbers: true,
          requireSymbols: true,
          requireUppercase: true,
          temporaryPasswordValidityDays: 3,
        },
      },
      schema: [
        {
          attributeDataType: 'String',
          required: true,
          mutable: true,
          name: 'email'
        }
      ],
      usernameAttributes: ['email'],
      usernameConfiguration: {
        caseSensitive: false,
      },
      userPoolAddOns: {
        advancedSecurityMode: 'ENFORCED',           // Enable advanced security
      },
      userPoolName: 'webapp-ui-cognito-userpool',
      emailVerificationMessage: 'Hello {username}, thanks for signing up to our awesome app! Please use this code to verify your account: {####}',
      emailVerificationSubject: 'Verify your email for our awesome app!',
      smsVerificationMessage: 'Hello {username}, thanks for signing up to our awesome app! Please use this code to verify your account: {####}',
      verificationMessageTemplate: {
        defaultEmailOption: 'CONFIRM_WITH_CODE',
        emailSubject: 'Confirm your account on our awesome app',
        emailSubjectByLink: 'Confirm your account on our awesome app',
        emailMessage: 'Hello {username},\n\nThanks for signing up to our awesome app!\n\nPlease use this code to verify your account: {####}',
        emailMessageByLink: 'Hello {username},\n\nThanks for signing up to our awesome app!\n\nPlease use this link to verify your account: {##Verify Email##}',
      },
    });

    cfnUserPool.applyRemovalPolicy(cdk.RemovalPolicy.DESTROY);

    // // Reference https://docs.aws.amazon.com/cdk/api/v1/docs/aws-apigateway-readme.html
    // const userPool = new cognito.UserPool(this, 'webapp-ui-cognito-userpool', {
    //   userPoolName: 'webapp-ui-cognito-userpool',
    //   selfSignUpEnabled: true,
    //   standardAttributes: {
    //     email: {
    //       required: true,
    //       mutable: true,
    //     }
    //   },
    //   mfa: cognito.Mfa.REQUIRED, // Set to optional and disable SMS by default due to text message setup maybe different between region
    //   mfaSecondFactor: {
    //     sms: false,
    //     otp: true,
    //   },
    //   signInAliases: {                    // Set to allow user to sign up with email
    //     email: true
    //   },
    //   userVerification: {
    //     emailSubject: 'Verify your email for our awesome app!',
    //     emailBody: 'Thanks for signing up to our awesome app! Your verification code is {####}',
    //     emailStyle: cognito.VerificationEmailStyle.CODE,
    //     smsMessage: 'Thanks for signing up to our awesome app! Your verification code is {####}',
    //   },
    //   accountRecovery: cognito.AccountRecovery.EMAIL_ONLY,
    //   removalPolicy: cdk.RemovalPolicy.DESTROY,
    //   passwordPolicy: {                           // Password policy to meet AwsSolutions-COG1
    //     minLength: 12,
    //     requireLowercase: true,
    //     requireUppercase: true,
    //     requireDigits: true,
    //     requireSymbols: true,
    //     tempPasswordValidity: Duration.days(3),
    //   },
    // });

    // Translate from cognito user pool L1 constructor to L2 for other setting to consumed
    const userPool = cognito.UserPool.fromUserPoolArn(this, 'web-ui-userpool', cfnUserPool.attrArn);

    // Enforced security setting
    new cognito.CfnUserPoolRiskConfigurationAttachment(this, 'cfnUserPool-attachment', {
      clientId: 'ALL',
      userPoolId: userPool.userPoolId,    
      accountTakeoverRiskConfiguration: {
        actions: {
          highAction: {
            eventAction: 'BLOCK',
            notify: false,
          },
          lowAction: {
            eventAction: 'NO_ACTION',
            notify: false,
          },
          mediumAction: {
            eventAction: 'MFA_IF_CONFIGURED',
            notify: false,
          },
        }
      }    
    });

    // Add a client for web ui sign in
    const cognitoAppClient = userPool.addClient('web-ui-app-client', {
      authFlows: {
        userPassword: true
      },
      oAuth: {
        flows: {
          implicitCodeGrant: true,
        },
        callbackUrls: [siteBucketWebsiteURL], // Set the redirect to the static site index page
        logoutUrls: [siteBucketWebsiteURL],   // Set the redirect to the static site index page
      },
      preventUserExistenceErrors: true  // Display generic error instead of user not found error for enhanced security
    });


    // Use the default cognito hosted domain for sign - in page
    const cognitoDomain = userPool.addDomain('cognitoDomain', {
      cognitoDomain: {
        domainPrefix: 'webapp-ui-userpool-s3-blob',   // Please change the domain to unique one if this one is taken
      },
    });

    const signInUrl = cognitoDomain.signInUrl(cognitoAppClient, {
      redirectUri: siteBucketWebsiteURL, // must be a URL configured under 'callbackUrls' with the client, in this case, it is the sample website
    })


    // Output for easier identification
    new cdk.CfnOutput(this, 'CognitoPoolID', { value: userPool.userPoolId });
    new cdk.CfnOutput(this, 'SignInURL', { value: signInUrl });

    return userPool;
  }
}
